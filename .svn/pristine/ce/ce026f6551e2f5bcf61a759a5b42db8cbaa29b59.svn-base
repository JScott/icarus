

var cameraTransform : Transform;
private var _target : Transform;
private var playerScript;

// The distance in the x-z plane to the target

var distance = 4.0;
var maxDistance = 7.0;
var minDistance = 3.0;
var dashMaxDistance = 15.0;

var rotateSpeed = 0.2;
private var idleTime = 0.0;

// the height we want the camera to be above the target
var height = 3.0;

var angularSmoothLag = 0.3;
var angularMaxSpeed = 15.0;

var heightSmoothLag = 0.3;

var snapSmoothLag = 0.2;
var snapMaxSpeed = 720.0;

var clampHeadPositionScreenSpace = 0.75;

var lockCameraTimeout = 0.2;
var leadTime = 0.7;

var dashZoom = 0.5;
//var dashDistance = 10.0;
private var tempDashMoveRay = Vector3.zero;

private var headOffset = Vector3.zero;
private var centerOffset = Vector3.zero;
private var lead = Vector3.zero;

private var heightVelocity = 0.0;
private var angleVelocity = 0.0;
private var snap = false;
private var controller : ThirdPersonController;
private var targetHeight = 100000.0;

function Awake ()
{
	if(!cameraTransform && Camera.main)
	cameraTransform = Camera.main.transform;
	if(!cameraTransform) {
		Debug.Log("Please assign a camera to the ThirdPersonCamera script.");
		enabled = false;
	}
	
	
	_target = transform;
	if (_target)
	{
		controller = _target.GetComponent(ThirdPersonController);
	}
	
	if (controller)
	{
		var characterController : CharacterController = _target.collider;
		centerOffset = characterController.bounds.center - _target.position;
		headOffset = centerOffset;
		headOffset.y = characterController.bounds.max.y - _target.position.y;
	}
	else
	Debug.Log("Please assign a target to the camera that has a ThirdPersonController script attached.");
	
	playerScript = GameObject.Find("Player").GetComponent(ThirdPersonController);
	Cut(_target, centerOffset);
}

function DebugDrawStuff ()
{
	Debug.DrawLine(_target.position, _target.position + headOffset);
	
}

function AngleDistance (a : float, b : float)
{
	a = Mathf.Repeat(a, 360);
	b = Mathf.Repeat(b, 360);
	
	return Mathf.Abs(b - a);
}

function Apply (dummyTarget : Transform, dummyCenter : Vector3)
{
	// Early out if we don't have a target
	if (!controller)
	return;
	
	var targetCenter = _target.position + centerOffset;
	var targetHead = _target.position + headOffset;
	
	//DebugDrawStuff();
	
	// Calculate the current & target rotation angles
	var originalTargetAngle = _target.eulerAngles.y;
	var currentAngle = cameraTransform.eulerAngles.y;
	
	// Adjust real target angle when camera is locked
	var targetAngle = originalTargetAngle;
	
	// When pressing Fire2 (alt) the camera will snap to the target direction real quick.
	// It will stop snapping when it reaches the target
	if (Input.GetButton("Fire2"))
		snap = true;
	
	if (snap)
	{
		// We are close to the target, so we can stop snapping now!
		if (AngleDistance (currentAngle, originalTargetAngle) < 3.0)
		snap = false;
		
		currentAngle = Mathf.SmoothDampAngle(currentAngle, targetAngle, angleVelocity, snapSmoothLag, snapMaxSpeed);
	}
	// Normal camera motion
	else
	{
		// Lock the camera when moving backwards!
		// * It is really confusing to do 180 degree spins when turning around.
		if (AngleDistance (currentAngle, targetAngle) > 160 && controller.IsMovingBackwards ())
		targetAngle += 180;
		
		currentAngle = Mathf.SmoothDampAngle(currentAngle, targetAngle, angleVelocity, angularSmoothLag, angularMaxSpeed);
	}
	
	
	// When jumping don't move camera upwards but only down!
	if (controller.IsJumping ())
	{
		// We'd be moving the camera upwards, do that only if it's really high
		var newTargetHeight = targetCenter.y + height;
		if (newTargetHeight < targetHeight || newTargetHeight - targetHeight > 5)
		targetHeight = targetCenter.y + height;
	}
	// When walking always update the target height
	else
	{
		targetHeight = targetCenter.y + height;
	}
	
	// Damp the height
	var currentHeight = cameraTransform.position.y;
	currentHeight = Mathf.SmoothDamp (currentHeight, targetHeight, heightVelocity, heightSmoothLag);
	
	// Convert the angle into a rotation, by which we then reposition the camera
	//var currentRotation = Quaternion.Euler (0, currentAngle, 0);
	
	// Set the position of the camera to:
	// follow the character if it gets too far or close
	var cameraMoveRay = cameraTransform.position - targetCenter;
	var originalMoveRay = cameraMoveRay;
	cameraMoveRay = Vector3.Normalize(cameraMoveRay);
	
	// Rotate the camera about the player
	// by first finding the angle between them...
	var camForward = cameraTransform.forward;
	camForward.y = 0;
	camForward = Vector3.Normalize(camForward);
	var targetForward = _target.transform.forward;
	targetForward.y = 0;
	targetForward = Vector3.Normalize(targetForward);
	
	// ...and the direction we'll turn to apply later
	var right = _target.transform.right;
	right.y = 0;
	right = Vector3.Normalize(right);
	var side = Mathf.Acos(Vector3.Dot(camForward, right));
	if (side.Equals(float.NaN)) side = 0;
	if (side < Mathf.PI/2) side = -1; // left
	else side = 1; // right
	
	// Set it the proper distance
	distance = Vector3.Distance(cameraTransform.position, targetCenter);
	var moveCam = false;
	var angle = Vector3.Angle(camForward,targetForward);
	
	// Dashing-related variables
	var charging = playerScript.IsJetCharging();
	var charged = playerScript.IsJetCharged();
	var dashing = playerScript.IsDashing();
	var zoomFactor = 1 - dashZoom*(playerScript.jetPowerUpCounter/playerScript.jetPowerUpTime);
	var realMaxDistance = charging ? dashMaxDistance : maxDistance;
					
	if (charging && !dashing) // While charging
	{
		if (tempDashMoveRay.Equals(Vector3.zero))
		{
			tempDashMoveRay = originalMoveRay;
		}
		if (!charged) // Zoom in until charged
		{
			moveCam = true;
			cameraMoveRay = tempDashMoveRay * zoomFactor;
		}
	}
	else if (distance > realMaxDistance)
	{
		moveCam = true;
		if (dashing) cameraMoveRay *= realMaxDistance;
		else cameraMoveRay *= Mathf.Lerp(distance, realMaxDistance, 0.12);
	}
	else if (distance < minDistance)
	{
		var sideWithDeadZone = angle < 179 ? side : -1;
		moveCam = true;
		cameraMoveRay = Quaternion.Euler(0, sideWithDeadZone, 0) * cameraMoveRay;
		cameraMoveRay *= minDistance + 0.01;
	}
	if (moveCam)
	{
		cameraTransform.position = targetCenter;
		cameraTransform.position += cameraMoveRay;
	}
	if (!charging)
	{
		tempDashMoveRay = Vector3.zero;
	}
	
	// Rotate to align if idle
	idleTime += Time.deltaTime;
	if (angle <= rotateSpeed)
	{
		cameraTransform.transform.RotateAround(targetCenter, Vector3.up, side * angle);
	}
	else if (idleTime > 3)
	{
		cameraTransform.transform.RotateAround(targetCenter, Vector3.up, side * rotateSpeed);
		if (controller.GetLockCameraTimer () < lockCameraTimeout)
		{
			idleTime = 0.0;
		}
	}
	
	// Set the height of the camera
	if (charging)
	{
		var tempHeight = targetCenter.y + (height * Mathf.Pow(zoomFactor,0.2));
		tempHeight = Mathf.SmoothDamp (currentHeight, tempHeight, heightVelocity, heightSmoothLag);
		cameraTransform.position.y = tempHeight;
	}
	else cameraTransform.position.y = currentHeight;
	
	// Always look at the target
	var newLead = controller.GetDirection() * controller.GetSpeed();
	newLead = Vector3.Project(newLead, cameraTransform.right);
	if (charging) newLead = Vector3.zero;
	lead = Vector3.Lerp(lead, newLead, Time.deltaTime * leadTime);
	SetUpRotation(targetCenter + lead, targetHead);
}

function LateUpdate () {
	Apply (transform, Vector3.zero);
}

function Cut (dummyTarget : Transform, dummyCenter : Vector3)
{
	var oldHeightSmooth = heightSmoothLag;
	var oldSnapMaxSpeed = snapMaxSpeed;
	var oldSnapSmooth = snapSmoothLag;
	
	snapMaxSpeed = 10000;
	snapSmoothLag = 0.001;
	heightSmoothLag = 0.001;
	
	snap = true;
	Apply (transform, Vector3.zero);
	
	heightSmoothLag = oldHeightSmooth;
	snapMaxSpeed = oldSnapMaxSpeed;
	snapSmoothLag = oldSnapSmooth;
}

function SetUpRotation (centerPos : Vector3, headPos : Vector3)
{
	// Now it's getting hairy. The devil is in the details here, the big issue is jumping of course.
	// * When jumping up and down we don't want to center the guy in screen space.
	//  This is important to give a feel for how high you jump and avoiding large camera movements.
	//
	// * At the same time we dont want him to ever go out of screen and we want all rotations to be totally smooth.
	//
	// So here is what we will do:
	//
	// 1. We first find the rotation around the y axis. Thus he is always centered on the y-axis
	// 2. When grounded we make him be centered
	// 3. When jumping we keep the camera rotation but rotate the camera to get him back into view if his head is above some threshold
	// 4. When landing we smoothly interpolate towards centering him on screen
	var cameraPos = cameraTransform.position;
	var offsetToCenter = centerPos - cameraPos;
	
	// Generate base rotation only around y-axis
	var yRotation = Quaternion.LookRotation(Vector3(offsetToCenter.x, 0, offsetToCenter.z));
	
	var relativeOffset = Vector3.forward * distance + Vector3.down * height;
	cameraTransform.rotation = yRotation * Quaternion.LookRotation(relativeOffset);
	
	// Calculate the projected center position and top position in world space
	var centerRay = cameraTransform.camera.ViewportPointToRay(Vector3(.5, 0.5, 1));
	var topRay = cameraTransform.camera.ViewportPointToRay(Vector3(.5, clampHeadPositionScreenSpace, 1));
	
	var centerRayPos = centerRay.GetPoint(distance);
	var topRayPos = topRay.GetPoint(distance);
	
	var centerToTopAngle = Vector3.Angle(centerRay.direction, topRay.direction);
	
	var heightToAngle = centerToTopAngle / (centerRayPos.y - topRayPos.y);
	
	var extraLookAngle = heightToAngle * (centerRayPos.y - centerPos.y);
	if (extraLookAngle < centerToTopAngle)
	{
		extraLookAngle = 0;
	}
	else
	{
		extraLookAngle = extraLookAngle - centerToTopAngle;
		cameraTransform.rotation *= Quaternion.Euler(-extraLookAngle, 0, 0);
	}
}

function GetCenterOffset ()
{
	return centerOffset;
}
