
// Require a character controller to be attached to the same game object
@script RequireComponent(CharacterController)

public var idleAnimation : AnimationClip;
public var walkAnimation : AnimationClip;
public var runAnimation : AnimationClip;
public var jumpPoseAnimation : AnimationClip;

public var walkMaxAnimationSpeed : float = 0.75;
public var runMaxAnimationSpeed : float = 1.0;
public var jumpAnimationSpeed : float = 1.15;
public var landAnimationSpeed : float = 1.0;

private var _animation : Animation;

var shadow : Projector;

enum CharacterState {
	Idle = 0,
	Walking = 1,
	Running = 2,
	Jumping = 3,
}

private var _characterState : CharacterState;

// The speed when walking
var walkSpeed = 15.0;
// when pressing "Fire3" button (cmd) we start running
var dashSpeed = 30.0;

var inAirControlAcceleration = 3.0;

// How high do we jump when pressing jump and letting go immediately
var jumpHeight = 0.5;
var doubleJumpHeight = 1.0;

// The gravity for the character
var gravity = 20.0;
// The gravity in controlled descent mode
var speedSmoothing = 10.0;
var rotateSpeed = 500.0;

// The percentage speed when double jumping or hovering
var doubleJumpDrag = 0.8;

// The time we can hover and how slow we fall
var hoverFallDrag = 0.5;
var hoverTimeout = 0.5;
var hoverPopUp = 2.0;
var hoverPopDown = -1.0;
private var hoverTimeoutCounter = -1.0;

var canJump = true;
var canDoubleJump = true;
var canHover = true;
var canDash = true;

private var jumpRepeatTime = 0.05;
private var jumpTimeout = 0.15;
private var groundedTimeout = 0.25;

// The camera doesnt start following the target immediately but waits for a split second to avoid too much waving around.
private var lockCameraTimer = 0.0;

// The current move direction in x-z
private var moveDirection = Vector3.zero;
// The current vertical speed
private var verticalSpeed = 0.0;
// The current x-z move speed
private var moveSpeed = 0.0;
var hoverSpeedCap = 1.0;

var jetPowerUpCounter = 0.0;
var jetPowerUpTime = 1.0;
var dashRotateDrag = 1.0/3.0;
var slideRotateDrag = 1.0/9.0;

// The last collision flags returned from controller.Move
private var collisionFlags : CollisionFlags;

// Are we jumping? (Initiated with jump button and not grounded yet)
private var jumping = false;
private var jumpingReachedApex = false;
private var doubleJumping = false;
private var hovering = false;
private var dashing = false;
private var sliding = false;

// Are we moving backwards (This locks the camera to not do a 180 degree spin)
private var movingBack = false;
// Is the user pressing any keys?
private var isMoving = false;
// Last time the jump button was clicked down
private var lastJumpButtonTime = -10.0;
// Last time we performed a jump
private var lastJumpTime = -1.0;


// the height we jumped from (Used to determine for how long to apply extra jump power after jumping.)
private var lastJumpStartHeight = 0.0;


private var inAirVelocity = Vector3.zero;
var maxInAirSpeed = 3.0;

private var lastGroundedTime = 0.0;


private var isControllable = true;

function Awake ()
{
	hoverTimeoutCounter = hoverTimeout;
	moveDirection = transform.TransformDirection(Vector3.forward);
	
	_animation = GetComponent(Animation);
	if(!_animation)
	Debug.Log("The character you would like to control doesn't have animations. Moving her might look weird.");
	
	/*
	public var idleAnimation : AnimationClip;
	public var walkAnimation : AnimationClip;
	public var runAnimation : AnimationClip;
	public var jumpPoseAnimation : AnimationClip;
	*/
	if(!idleAnimation) {
		_animation = null;
		Debug.Log("No idle animation found. Turning off animations.");
	}
	if(!walkAnimation) {
		_animation = null;
		Debug.Log("No walk animation found. Turning off animations.");
	}
	if(!runAnimation) {
		_animation = null;
		Debug.Log("No run animation found. Turning off animations.");
	}
	if(!jumpPoseAnimation && canJump) {
		_animation = null;
		Debug.Log("No jump animation found and the character has canJump enabled. Turning off animations.");
	}
	
}


function UpdateSmoothedMovementDirection ()
{
	var cameraTransform = Camera.main.transform;
	var grounded = IsGrounded();
	
	// Forward vector relative to the camera along the x-z plane
	var forward = cameraTransform.TransformDirection(Vector3.forward);
	forward.y = 0;
	forward = forward.normalized;
	
	// Right vector relative to the camera
	// Always orthogonal to the forward vector
	var right = Vector3(forward.z, 0, -forward.x);
	
	var v = Input.GetAxisRaw("Vertical");
	var h = Input.GetAxisRaw("Horizontal");
	
	// Are we moving backwards or looking backwards
	/*if (v < -0.2)
	movingBack = true;
	else
	movingBack = false;
	*/
	var wasMoving = isMoving;
	isMoving = Mathf.Abs (h) > 0.1 || Mathf.Abs (v) > 0.1;
	
	// Target direction relative to the camera
	var targetDirection = h * right + v * forward;
	
	// Grounded controls
	if (grounded)
	{
		// Lock camera for short period when transitioning moving & standing still
		lockCameraTimer += Time.deltaTime;
		if (isMoving != wasMoving)
		lockCameraTimer = 0.0;
		
		// We store speed and direction seperately,
		// so that when the character stands still we still have a valid forward direction
		// moveDirection is always normalized, and we only update it if there is user input.
		sliding = false;
		if (IsJetCharging() && !IsDashing())
		{
			// Player rooted
		}
		else if (targetDirection != Vector3.zero)
		{
			if (IsDashing())
			{
				var rotateSpeedModifier = 1.0;
				if (IsDashing())
				{
					if (Input.GetButton("Jump"))
					{
						sliding = true;
						rotateSpeedModifier = slideRotateDrag;
					}
					else rotateSpeedModifier = dashRotateDrag;
				}
				var modifiedRotateSpeed = rotateSpeed*rotateSpeedModifier;
				moveDirection = Vector3.RotateTowards(moveDirection, targetDirection, modifiedRotateSpeed * Mathf.Deg2Rad * Time.deltaTime, 1000);
				moveDirection = moveDirection.normalized;
			}
			else
			{
				// If we are really slow, just snap to the target direction
				// TODO: also if we're going the opposite direction, just do a skid first
				if (moveSpeed < walkSpeed * 0.9 && grounded)
				{
					moveDirection = targetDirection.normalized;
				}
				// Otherwise smoothly turn towards it
				else
				{
					moveDirection = Vector3.RotateTowards(moveDirection, targetDirection, rotateSpeed * Mathf.Deg2Rad * Time.deltaTime, 1000);
					moveDirection = moveDirection.normalized;
				}
			}
		}
		// Smooth the speed based on the current target direction
		var curSmooth = speedSmoothing * Time.deltaTime;
		
		// Choose target speed
		//* We want to support analog input but make sure you cant walk faster diagonally than just forward or sideways
		var targetSpeed = Mathf.Min(targetDirection.magnitude, 1.0);
		
		_characterState = CharacterState.Idle;
		
		// TODO: replace with dash
		//targetSpeed *= runSpeed;
		//_characterState = CharacterState.Running;
		targetSpeed *= walkSpeed;
		_characterState = CharacterState.Walking;
		
		if (IsJetCharging())
		{
			// Root the player
			targetSpeed = 0;
		}
		
		if (IsDashing())
		{
			moveSpeed = dashSpeed;
			if (IsHittingAWall())
			{
				// TODO: bounce backward when you collide with something
				// make it a reusable function for use with enemies as well
			}
		}
		else moveSpeed = Mathf.Lerp(moveSpeed, targetSpeed, curSmooth);
	}
	// In air controls
	else if (!IsJetCharging()) // because "grounded" isn't perfect
	{
		// Lock camera while in air
		if (jumping || doubleJumping)
		lockCameraTimer = 0.0;
		
		// Restrict air movement
		if (isMoving)
		{
			inAirVelocity += targetDirection.normalized * Time.deltaTime * inAirControlAcceleration;
			//inAirVelocity = Vector3.Project(inAirVelocity, transform.right);
			if (inAirVelocity.magnitude > maxInAirSpeed)
			inAirVelocity = Vector3.Normalize(inAirVelocity)*maxInAirSpeed;
		}
		// Slow down when hovering
		if (IsHovering()) moveSpeed = Mathf.Min(moveSpeed, hoverSpeedCap);
	}
	
}


function ApplyJumping ()
{
	// Prevent jumping too fast after each other
	if (lastJumpTime + jumpRepeatTime > Time.time)
	return;
	
	if (IsGrounded()) {
		// Jump
		// - Only when pressing the button down
		// - With a timeout so you can press the button slightly before landing
		if (canJump && Time.time < lastJumpButtonTime + jumpTimeout) {
			verticalSpeed = CalculateJumpVerticalSpeed (jumpHeight);
			SendMessage("DidJump", SendMessageOptions.DontRequireReceiver);
		}
	}
	else if (IsJumping() && !IsDoubleJumping())
	{
		if (canDoubleJump && Time.time < lastJumpButtonTime + jumpTimeout)
		{
			verticalSpeed = CalculateJumpVerticalSpeed (doubleJumpHeight);
			SendMessage("DidDoubleJump", SendMessageOptions.DontRequireReceiver);
		}
	}
}

function ApplyGravity ()
{
	if (isControllable)// don't move player at all if not controllable.
	{
		// Apply gravity
		var jumpButton = Input.GetButton("Jump");
		
		// When we reach the apex of the jump we send out a message
		if ((jumping || doubleJumping) && !jumpingReachedApex && verticalSpeed <= 0.0)
		{
			jumpingReachedApex = true;
			SendMessage("DidJumpReachApex", SendMessageOptions.DontRequireReceiver);
		}
		
		if (IsGrounded ()){
			verticalSpeed = 0.0;
			hoverTimeoutCounter = hoverTimeout;
		}
		else
		{
			var shouldHover = canHover && IsHovering() && jumpingReachedApex && hoverTimeoutCounter > 0;
			if (shouldHover) {
				hoverTimeoutCounter -= Time.deltaTime;
				if (IsHoverEnding()){
					// Hop a little
					verticalSpeed = hoverPopUp;
					if (hoverTimeoutCounter < 0) verticalSpeed = hoverPopDown;
					
					// End hovering
					if (IsHovering()) SendMessage("DidHoverEnd", SendMessageOptions.DontRequireReceiver);
				}
			}
			var verticalDrag = shouldHover ? hoverFallDrag : 1;
			var modifiedGravity = IsDashing() ? gravity*0.75 : gravity;
			verticalSpeed -= modifiedGravity * verticalDrag * Time.deltaTime;
		}
	}
}

function CalculateJumpVerticalSpeed (targetJumpHeight : float)
{
	// From the jump height and gravity we deduce the upwards speed
	// for the character to reach at the apex.
	return Mathf.Sqrt(2 * targetJumpHeight * gravity);
}

function DidJump ()
{
	jumping = true;
	jumpingReachedApex = false;
	lastJumpTime = Time.time;
	lastJumpStartHeight = transform.position.y;
	lastJumpButtonTime = -10;
	
	_characterState = CharacterState.Jumping;
}

function DidDoubleJump()
{
	doubleJumping = true;
	jumpingReachedApex = false;
	//lastJumpTime = Time.time;
	//lastJumpStartHeight = transform.position.y;
	//lastJumpButtonTime = -10;
	_characterState = CharacterState.Jumping;
	SmokePuff();
}

function DidHoverEnd()
{
	hovering = false;
	SmokePuff();
}

function SmokePuff()
{
	GameObject.Find("Smoke").GetComponent(ParticleEmitter).particleEmitter.Emit();
}

function DashEndDust()
{
	GameObject.Find("DashEndDust").GetComponent(ParticleEmitter).particleEmitter.Emit();
}

function Update() {
	
	if (!isControllable)
	{
		// kill all inputs if not controllable.
		Input.ResetInputAxes();
	}
	
	// Jump button
	if (Input.GetButtonDown ("Jump"))
	{
		// Dash
		if (IsJetCharged())
		{
			dashing = true;
		}
		
		// Jump
		else if (!IsJetCharging() && !IsDashing())
		{
			lastJumpButtonTime = Time.time;
		}
	}
	
	// Jet Power Up
	if (IsJetCharging() && !IsJumping())
	{
		if (jetPowerUpCounter < jetPowerUpTime)
		{
			jetPowerUpCounter = Mathf.Min(jetPowerUpCounter + Time.deltaTime, jetPowerUpTime);
			if (IsJetPowered()) audio.Play();
		}
	}
	else
	{
		if (jetPowerUpCounter > 0) jetPowerUpCounter = Mathf.Max(jetPowerUpCounter - Time.deltaTime, 0);
	}
	
	// Hovering
	if (Input.GetButtonDown("Jets") && !IsGrounded())
	{
		hovering = true;
		if (verticalSpeed < 0) verticalSpeed = -0.1;
	}
	if (Input.GetButtonUp("Jets"))
	{
		hovering = false;
		if (dashing)
		{
			dashing = false;
			DashEndDust();
		}
		jetPowerUpCounter = 0.0;
	}
	
	UpdateSmoothedMovementDirection();
	
	// Apply gravity
	// - extra power jump modifies gravity
	// - controlledDescent mode modifies gravity
	ApplyGravity ();
	
	// Apply jumping logic
	ApplyJumping ();
	
	// Calculate actual motion
	var modifiedMoveSpeed = IsDoubleJumping() ? moveSpeed * doubleJumpDrag : moveSpeed;
	//var movement = moveDirection * modifiedMoveSpeed + Vector3 (0, verticalSpeed, 0) + inAirVelocity;
	//var modifiedInAirVelocity = IsDoubleJumping() ? 
	var movement = moveDirection * modifiedMoveSpeed + Vector3(0, verticalSpeed, 0) + inAirVelocity;
	movement *= Time.deltaTime;
	
	// Move the controller
	var controller : CharacterController = GetComponent(CharacterController);
	collisionFlags = controller.Move(movement);
	var shadowY = transform.position.y + 4;
	/*if (IsJumping())
	{
		shadowY = lastJumpStartHeight + 4;
		var jumpingHeight = transform.position.y - lastJumpStartHeight;
		shadowY -= jumpingHeight/2;
		//shadow.material.color.a = (4.0 - jumpingHeight) / 4.0;
		//Debug.Log(shadow.material.color.a);
	}*/
	
	
	
	
	
	// VISUAL sector
	// Add a shadow to the character
	shadow.transform.position = Vector3(transform.position.x, shadowY, transform.position.z);
	
	// Turn on/off hovering effects
	var hoverEffects = IsHovering();
	var hoverEndEffects = IsHoverEnding();
	GameObject.Find("InnerCore").GetComponent(ParticleEmitter).particleEmitter.emit = 
		GameObject.Find("Lightsource").light.enabled = 
		hoverEffects;
	
	// ANIMATION sector
	if(_animation) {
		if(_characterState == CharacterState.Jumping)
		{
			if(!jumpingReachedApex) {
				_animation[jumpPoseAnimation.name].speed = jumpAnimationSpeed;
				_animation[jumpPoseAnimation.name].wrapMode = WrapMode.ClampForever;
				_animation.CrossFade(jumpPoseAnimation.name);
			} else {
				_animation[jumpPoseAnimation.name].speed = -landAnimationSpeed;
				_animation[jumpPoseAnimation.name].wrapMode = WrapMode.ClampForever;
				_animation.CrossFade(jumpPoseAnimation.name);
			}
		}
		else
		{
			if(controller.velocity.sqrMagnitude < 0.1) {
				_animation.CrossFade(idleAnimation.name);
			}
			else
			{
				if(_characterState == CharacterState.Running) {
					_animation[runAnimation.name].speed = Mathf.Clamp(controller.velocity.magnitude, 0.0, runMaxAnimationSpeed);
					_animation.CrossFade(runAnimation.name);
				}
				else if(_characterState == CharacterState.Walking) {
					_animation[walkAnimation.name].speed = Mathf.Clamp(controller.velocity.magnitude, 0.0, walkMaxAnimationSpeed);
					_animation.CrossFade(walkAnimation.name);
				}
				
			}
		}
	}
	// ANIMATION sector
	
	// Set rotation to the move direction
	if (IsGrounded() && (!IsJetCharging() || IsDashing()))
	{
		
		transform.rotation = Quaternion.LookRotation(moveDirection);
		
	}
	else
	{ //TODO: rework facing directions altogether. right now it's just kind of off
		var xzMove = movement;
		xzMove.y = 0;
		if (xzMove.sqrMagnitude > 0.001)
		{
			//transform.rotation = Quaternion.LookRotation(xzMove);
		}
	}
	
	// We are in jump mode but just became grounded
	if (IsGrounded())
	{
		lastGroundedTime = Time.time;
		inAirVelocity = Vector3.zero;
		if (jumping || doubleJumping || hovering)
		{
			if (hovering || doubleJumping)
			{
				moveSpeed = 0;
			}
		
			jumping = false;
			doubleJumping = false;
			hovering = false;
			hoverEndingCounter = 0.0;
			SendMessage("DidLand", SendMessageOptions.DontRequireReceiver);
		}
	}
}

function OnControllerColliderHit (hit : ControllerColliderHit )
{
	//Debug.DrawRay(hit.point, hit.normal);
	if (hit.moveDirection.y > 0.01)
	return;
}

function GetSpeed () {
	return moveSpeed;
}

function IsJumping () {
	return jumping;
}

function IsDoubleJumping() {
	return doubleJumping;
}

function IsHovering() {
	return hovering;
}

function IsHoverEnding() {
	return hoverTimeoutCounter < 0.2;
}

// TODO: crash when dashing and collide
function IsDashing() {
	// You know it B)
	return dashing;
}

function IsJetPowered() {
	return jetPowerUpCounter == jetPowerUpTime;
}

function IsGrounded () {
	return (collisionFlags & CollisionFlags.CollidedBelow) != 0;
}

function IsHittingAWall() {
	return (collisionFlags & CollisionFlags.CollidedSides) != 0;
}

function GetDirection () {
	return moveDirection;
}

function IsMovingBackwards () {
	return movingBack;
}

public function IsJetCharging() {
	return Input.GetButton("Jets") && (IsGrounded() || jetPowerUpCounter > 0);
}

function IsJetCharged() {
	return jetPowerUpCounter == jetPowerUpTime;
}

function GetLockCameraTimer ()
{
	return lockCameraTimer;
}

function IsMoving ()  : boolean
{
	return Mathf.Abs(Input.GetAxisRaw("Vertical")) + Mathf.Abs(Input.GetAxisRaw("Horizontal")) > 0.5;
}

function HasJumpReachedApex ()
{
	return jumpingReachedApex;
}

function IsGroundedWithTimeout ()
{
	return lastGroundedTime + groundedTimeout > Time.time;
}

function Reset ()
{
	gameObject.tag = "Player";
}

